# -*- coding: utf-8 -*-
"""ADD2023_Data_load.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15toqL6fqpLr_tKtH7ACAFSKxsXTivFZg
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/STUDY/Project/ADD2023/data
!tar -xzf track1_2-dev.tar.gz

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/STUDY/Project/ADD2023

from pathlib import Path

target_dir = Path("/content/drive/MyDrive/STUDY/Project/ADD2023/data/Track1.2/dev/librosa")

file_count = sum(1 for p in target_dir.iterdir() if p.is_file())

print(f"파일 개수: {file_count}개")

from pathlib import Path

target_dir = Path("/content/drive/MyDrive/STUDY/Project/ADD2023/data/Track1.2/dev/wav")

file_count = sum(1 for p in target_dir.iterdir() if p.is_file())

print(f"파일 개수: {file_count}개")

import os
import numpy as np
import pandas as pd
import librosa
from tqdm.notebook import tqdm
import pickle

# ====경로설정=====
label_path = "data/Track1.2/dev/label.txt"

# ====레이블 불러오기====
df_val_labels = pd.read_csv(label_path, sep=" ", header=None, names=["filename", "label"])

# ====오디오 로드 ===
audio_dir = "data/Track1.2/dev/wav/"
save_dir = "data/Track1.2/dev/librosa/"

os.makedirs(save_dir, exist_ok=True)

missing_files = []   # 나중에 보고할 용도

for filename, label in tqdm(zip(df_val_labels["filename"], df_val_labels["label"]),
                            total=len(df_val_labels)):
    file_path = os.path.join(audio_dir, filename)

    # 파일이 실제로 존재하는지 먼저 확인
    if not os.path.exists(file_path):
        missing_files.append(filename)
        print(f"⚠️ 원본 wav 파일 없음: {file_path}")
        continue

    try:
        # 1) 오디오 로드
        audio, _ = librosa.load(file_path, sr=16000)

        # 2) 저장할 파일명: 원래 파일명에서 디렉터리 제거하고 확장자만 바꿈
        base_name = os.path.basename(filename)                    # 안전하게 파일명만 추출
        save_name = os.path.splitext(base_name)[0] + ".npy"       # 확장자 교체 (robust)
        save_path = os.path.join(save_dir, save_name)

        # 3) .npy 파일로 즉시 저장
        np.save(save_path, audio)

    except Exception as e:
        # 저장/로드 중 발생한 예외를 명확히 출력
        print(f"⚠️ 오류 발생: {filename} | {e}")

# 완료 후 요약
print("작업 완료")
if missing_files:
    print(f"원본 wav가 없어 처리하지 못한 파일 수: {len(missing_files)}")
    # 필요하면 missing_files를 파일로 저장
    with open("missing_wav_files.txt", "w") as f:
        for fn in missing_files:
            f.write(fn + "\n")
    print("missing_wav_files.txt에 목록 저장.")

import os
import numpy as np
from tqdm import tqdm

def load_saved_npy(save_dir):
    filenames = sorted([f for f in os.listdir(save_dir) if f.endswith(".npy")])
    audios = []

    print(f"총 {len(filenames)}개 파일 로딩 시작\n")

    for f in tqdm(filenames, desc="Loading .npy files"):
        file_path = os.path.join(save_dir, f)
        audio = np.load(file_path)
        audios.append(audio)

        # 파일명 출력 (원하면 제거 가능)
        print(f"Loaded: {f}")

    return audios

save_dir = "data/Track1.2/dev/librosa/"
val_audios = load_saved_npy(save_dir)
print("로드된 배열 개수:", len(val_audios))

lengths = [len(a) for a in val_audios]
print(f"최소 길이: {min(lengths)}")
print(f"최대 길이: {max(lengths)}")
print(f"평균 길이: {np.mean(lengths)}")

"""## MFCC 추출"""

import os
import numpy as np
from tqdm import tqdm
import librosa

# ---- 경로 설정 ----
load_dir = "data/Track1.2/dev/librosa"   # raw audio npy가 저장된 폴더
save_dir = "data/Track1.2/dev/mfcc"      # MFCC 저장 폴더
os.makedirs(save_dir, exist_ok=True)

# ---- MFCC 설정 ----
sr = 16000
n_fft = 400
hop_length = 160
n_mfcc = 40

# ---- 파일 목록 ----
file_list = sorted([f for f in os.listdir(load_dir) if f.endswith(".npy")])

print(f"총 {len(file_list)}개 raw audio 로딩 후 MFCC 추출 시작\n")

# ---- MFCC 생성 루프 ----
for fname in tqdm(file_list, desc="Extracting MFCC"):
    load_path = os.path.join(load_dir, fname)

    try:
        # 1) numpy raw audio 로드
        audio = np.load(load_path)

        # 2) MFCC 계산
        mfcc = librosa.feature.mfcc(
            y=audio,
            sr=sr,
            n_fft=n_fft,
            hop_length=hop_length,
            n_mfcc=n_mfcc
        )

        # 3) 저장 파일명 (확장자만 유지)
        save_path = os.path.join(save_dir, fname)

        # 4) npy로 저장
        np.save(save_path, mfcc)

    except Exception as e:
        print(f"⚠️ 오류: {fname} 처리 중 문제 발생 → {e}")

print("\n✅ MFCC 변환 완료!")

import numpy as np
import matplotlib.pyplot as plt
import os

# 저장된 MFCC 파일 경로 (예: 첫 번째 파일 확인)
mfcc_dir = "data/Track1.2/dev/mfcc"
mfcc_files = sorted([f for f in os.listdir(mfcc_dir) if f.endswith(".npy")])

# 하나를 선택해서 로드
sample_path = os.path.join(mfcc_dir, mfcc_files[1])
mfcc = np.load(sample_path)

print("MFCC shape:", mfcc.shape)   # (40, T) 형태 예상

# 시각화
plt.figure(figsize=(10, 4))
plt.imshow(mfcc, aspect="auto", origin="lower")
plt.colorbar(label="Magnitude")
plt.xlabel("Time frames")
plt.ylabel("MFCC Coefficients")
plt.title(f"MFCC Example: {mfcc_files[0]}")
plt.show()

lengths = []

for fname in tqdm(mfcc_files):
    path = os.path.join(mfcc_dir, fname)
    mfcc = np.load(path)  # shape: (n_mfcc, time_frames)
    lengths.append(mfcc.shape[1])  # 프레임 길이

lengths = np.array(lengths)

print("총 파일 수:", len(lengths))
print("MFCC 프레임 길이 최소:", lengths.min())
print("MFCC 프레임 길이 최대:", lengths.max())
print("MFCC 프레임 길이 평균:", lengths.mean())
print("MFCC 프레임 길이 중간값:", np.median(lengths))
print("MFCC 프레임 길이 표준편차:", lengths.std())

# (옵션) 길이 분포도 보고 싶다면:
try:
    import matplotlib.pyplot as plt
    plt.hist(lengths, bins=50)
    plt.title("MFCC Frame Length Distribution")
    plt.xlabel("Frame length")
    plt.ylabel("Count")
    plt.show()
except:
    print("matplotlib이 없어서 히스토그램은 생략됨.")